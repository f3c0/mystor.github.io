<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Nika's Box - mozilla</title><link href="https://mystor.github.io/" rel="alternate"></link><link href="https://mystor.github.io/feeds/categories/mozilla.atom.xml" rel="self"></link><id>https://mystor.github.io/</id><updated>2019-02-04T13:45:00-05:00</updated><entry><title>Fission Engineering Newsletter #1</title><link href="https://mystor.github.io/fission-news-1.html" rel="alternate"></link><published>2019-02-04T09:00:00-05:00</published><updated>2019-02-04T13:45:00-05:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2019-02-04:/fission-news-1.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; Fission is happening and our first "Milestone" is targeted at
the end of February. Please file bugs related to fission and mark them as
"Fission Milestone: ?" so we can triage them into the correct milestone.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A little than more a year ago, a serious security flaw affecting almost …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt; Fission is happening and our first "Milestone" is targeted at
the end of February. Please file bugs related to fission and mark them as
"Fission Milestone: ?" so we can triage them into the correct milestone.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A little than more a year ago, a serious security flaw affecting almost all
modern processors was &lt;a href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html"&gt;publicly disclosed&lt;/a&gt;. Three known variants of the issue
were announced with the names dubbed as &lt;a href="https://spectreattack.com/spectre.pdf"&gt;Spectre&lt;/a&gt; (variants 1 and 2) and
&lt;a href="https://meltdownattack.com/meltdown.pdf"&gt;Meltdown&lt;/a&gt; (variant 3). Spectre abuses a CPU optimization technique known
as speculative execution to exfiltrate secret data stored in memory of other
running programs via side channels. This might include cryptographic keys,
passwords stored in a password manager or browser, cookies, etc. This timing
attack posed a serious threat to the browsers because webpages often serve
JavaScript from multiple domains that run in the same process. This
vulnerability would enable malicious third-party code to steal sensitive user
data belonging to a site hosting that code, a serious flaw that would violate
a web security cornerstone known as &lt;a href="https://en.m.wikipedia.org/wiki/Same-origin_policy"&gt;Same-origin policy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks to the heroic efforts of the Firefox JS and Security teams, we were
able to mitigate these vulnerabilities right away. However, these mitigations
may not save us in the future if another security vulnerability is released
exploiting the same underlying problem of sharing processes (and hence,
memory) between different domains, some of which may be malicious. Chrome
spent multiple years working to isolate sites in their own processes.&lt;/p&gt;
&lt;p&gt;We aim to build a browser which isn't just secure against known security
vulnerabilities, but also has layers of built-in defense against potential
future vulnerabilities. To accomplish this, we need to revamp the
architecture of Firefox and support full Site Isolation. We call this next
step in the evolution of Firefox’s process model "&lt;strong&gt;Project Fission&lt;/strong&gt;". While
Electrolysis split our browser into Content and Chrome, with Fission, we will
"split the atom", splitting cross-site iframes into different processes than
their parent frame.&lt;/p&gt;
&lt;p&gt;Over the last year, we have been working to lay the groundwork for Fission,
designing new infrastructure. In the coming weeks and months, we’ll need help
from all Firefox teams to adapt our code to a post-Fission browser
architecture.&lt;/p&gt;
&lt;h3&gt;Planning and Coordination&lt;/h3&gt;
&lt;p&gt;Fission is a massive project, spanning across many different teams, so keeping
track of what everyone is doing is a pretty big task. While we have a weekly
project meeting, which someone on your team may already be attending, we have
started also using a Bugzilla project tracking flag to keep track of the work
we have in progress.&lt;/p&gt;
&lt;p&gt;Now that we've moved past much of the initial infrastructure ground work, we
are going to keep track of work with our milestone targets. Each milestone
will contain a collection of new features and improved functionality which
brings us incrementally closer to our goal.&lt;/p&gt;
&lt;p&gt;Our first milestone, "Milestone 1" (clever, I know), is currently targeted
for the end of February. In Milestone 1, we plan to have the groundwork for
out-of-process iframes, which encompasses some major work, including, but not
limited to, the following contributions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;:rhunt&lt;/strong&gt; is implementing basic out-of-process iframe rendering behind a
  pref. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1500257"&gt;Bug 1500257&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:jdai&lt;/strong&gt; is implementing native JS Window Actor APIs to migrate FrameScripts.
  (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1467212"&gt;Bug 1467212&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:farre&lt;/strong&gt; is adding support for BrowsingContext fields to be
  synchronized between multiple content processes. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1523645"&gt;Bug 1523645&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:peterv&lt;/strong&gt; has implemented new cross-process WindowProxy objects to
  correctly emulate the &lt;code&gt;Window&lt;/code&gt; object APIs exposed to cross-origin documents.
  (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1353867"&gt;Bug 1353867&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:mattn&lt;/strong&gt; is converting the FormAutoFillListeners code to the actors infrastructure. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1474143"&gt;Bug 1474143&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:felipe&lt;/strong&gt; simulated the Fission API for communicating between parent and child processes. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1493984"&gt;Bug 1493984&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:heycam&lt;/strong&gt; is working on sharing UA stylesheets between processes. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1474793"&gt;Bug 1474793&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:kmag&lt;/strong&gt;, &lt;strong&gt;:erahm&lt;/strong&gt; and many others have reduced per-process memory overhead!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:jld&lt;/strong&gt; is working on async process launches&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:dragana&lt;/strong&gt;, &lt;strong&gt;:kershaw&lt;/strong&gt; and others are moving networking logic into a socket process. (&lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1322426"&gt;Bug 1322426&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;...and so much more!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want an up-to-date view of Milestone 1, you can see the &lt;a href="https://bugzilla.mozilla.org/buglist.cgi?classification=Client%20Software&amp;amp;classification=Developer%20Infrastructure&amp;amp;classification=Components&amp;amp;classification=Server%20Software&amp;amp;classification=Other&amp;amp;f1=cf_fission_milestone&amp;amp;list_id=14538804&amp;amp;o1=equals&amp;amp;query_format=advanced&amp;amp;v1=M1&amp;amp;query_based_on=&amp;amp;columnlist=product%2Ccomponent%2Cassigned_to%2Cshort_desc%2Cbug_status%2Cresolution%2Cstatus_whiteboard"&gt;current Milestone 1 status&lt;/a&gt;
on Bugzilla.&lt;/p&gt;
&lt;p&gt;If you have a bug which may be relevant to fission, &lt;em&gt;please&lt;/em&gt; let us know by
setting the "Fission Milestone" project flag to '?'. We'll swing by and
triage it into the correct milestone.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Setting Fission Milestone Project Flag" src="https://mystor.github.io/images/fission_milestone_select.png"&gt;&lt;/p&gt;
&lt;p&gt;If you have any questions, feel free to reach out to one of us, and we'll get
you answers, or guide you to someone who can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ron Manning &lt;code&gt;&amp;lt;rmanning@mozilla.com&amp;gt;&lt;/code&gt; (Fission Engineering Project Manager)&lt;/li&gt;
&lt;li&gt;Nika Layzell &lt;code&gt;&amp;lt;nika@mozilla.com&amp;gt;&lt;/code&gt; (Fission Tech Lead)&lt;/li&gt;
&lt;li&gt;Neha Kochar &lt;code&gt;&amp;lt;nkochar@mozilla.com&amp;gt;&lt;/code&gt; (DOM Fission Engineering Manager)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What's Changing?&lt;/h3&gt;
&lt;p&gt;In order to make each component of Firefox successfully adapt to a post-Fission
world, many of them are going to need changes of varying scale. Covering all of
the changes which we're going to need would be impossible within a single
newsletter. Instead, I will focus on the changes to actors, messageManagers,
and document hierarchies.&lt;/p&gt;
&lt;p&gt;Today, Firefox has process separation between the UI - run in the &lt;em&gt;parent
process&lt;/em&gt;, and web content - run in &lt;em&gt;content processes&lt;/em&gt;. Communication between
these two trees of "Browsing Contexts" is done using the &lt;code&gt;TabParent&lt;/code&gt; and
&lt;code&gt;TabChild&lt;/code&gt; actors in C++ code, and Message Managers in JS code. These systems
communicate directly between the "embedder", which in this case is the
&lt;code&gt;&amp;lt;browser&amp;gt;&lt;/code&gt; element, and the root of the embedded tree, which in this case
would be the toplevel DocShell in the tab.&lt;/p&gt;
&lt;p&gt;However, in a post-Fission world, this layer for communication is no longer
sufficient. It will be possible for multiple processes to render distinct
subframes, meaning that each tab has multiple connected processes.&lt;/p&gt;
&lt;p&gt;Components will need to adapt their IPC code to work in this new world, both by
updating their use of existing APIs, and by adapting to use new Actors and APIs
which are being added as part of the Fission project.&lt;/p&gt;
&lt;h4&gt;Per-Window Global Actors&lt;/h4&gt;
&lt;p&gt;For many components, the full tree of Browsing Contexts is not important,
rather communication is needed between the parent process and any specific
document. For these cases, a new actor has been added which is exposed both in
C++ code and JS code called &lt;a href="https://searchfox.org/mozilla-central/rev/60c4067b1cbb0f94d7dc2d7cdfa27ed579817fee/dom/ipc/PWindowGlobal.ipdl"&gt;PWindowGlobal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Unlike other actors in gecko, such as &lt;code&gt;Tab{Parent,Child}&lt;/code&gt;, this actor exists
for all window globals, including those loaded within the parent process. This
is handled using a new &lt;code&gt;PInProcess&lt;/code&gt; manager actor, which supports sending main
thread to main thread IPDL messages.&lt;/p&gt;
&lt;p&gt;JS code running within a FrameScript may not be able to inspect every frame at
once, and won't be able to handle events from out of process iframes. Instead,
it will need to use our new &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1467212"&gt;JS Window Actor&lt;/a&gt; APIs, which we are targeting to
land in Milestone 1. These actors are "managed" by the &lt;code&gt;WindowGlobal&lt;/code&gt; actors,
and are implemented as JS classes instantiated when requested for any
particular window. They support sending async messages, and will be present for
both in-process and out-of-process windows.&lt;/p&gt;
&lt;p&gt;C++ logic which walks the frame tree from the &lt;code&gt;TabChild&lt;/code&gt; may stop working.
Instead, C++ code may choose to use the PWindowGlobal actor to send messages in
a manner similar to JS code.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;BrowsingContext&lt;/code&gt; objects&lt;/h4&gt;
&lt;p&gt;C++ code may also maintain shared state on the &lt;code&gt;BrowsingContext&lt;/code&gt; object. We are
targeting landing the field syncing infrastructure in Milestone 1, and it will
provide a place to store data which should be readable by all processes with a
view of the structure.&lt;/p&gt;
&lt;p&gt;The parent process holds a special subclass of the &lt;code&gt;BrowsingContext&lt;/code&gt; object:
&lt;code&gt;CanonicalBrowsingContext&lt;/code&gt;. This object has extra fields which can be used in
the parent to keep track of the current status of all frames in one place.&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;TabParent&lt;/code&gt;, &lt;code&gt;TabChild&lt;/code&gt; and IFrames&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;Tab{Parent,Child}&lt;/code&gt; actors will continue to exist, and will always bridge
from the parent process to a content process. However, in addition to these
actors being present for toplevel documents, they will also be present for
out-of-process subtrees.&lt;/p&gt;
&lt;p&gt;As an example, consider the following tree of nested browsing contexts:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         +-- 1 --+
         | a.com |
         +-------+
          /     \
    +-- 2 --+ +-- 4 --+
    | a.com | | b.com |
    +-------+ +-------+
        |         |
    +-- 3 --+ +-- 5 --+
    | b.com | | b.com |
    +-------+ +-------+
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Under e10s, we have a single &lt;code&gt;Tab{Parent,Child}&lt;/code&gt; pair for the entire tab, which
would connect to &lt;code&gt;1&lt;/code&gt;, and FrameScripts would run with &lt;code&gt;content&lt;/code&gt; being the &lt;code&gt;1&lt;/code&gt;'s
global.&lt;/p&gt;
&lt;p&gt;After Fission, there will still be a &lt;code&gt;Tab{Parent,Child}&lt;/code&gt; actor for the root of
the tree, at &lt;code&gt;1&lt;/code&gt;. However, there will also be two additional &lt;code&gt;Tab{Parent,Child}&lt;/code&gt;
actors: one at &lt;code&gt;3&lt;/code&gt; and one at &lt;code&gt;4&lt;/code&gt;. Each of these nested &lt;code&gt;TabParent&lt;/code&gt; objects are
held alive in the parent process by a &lt;code&gt;RemoteFrameParent&lt;/code&gt; actor whose
corresponding &lt;code&gt;RemoteFrameChild&lt;/code&gt; is held by the embedder's iframe.&lt;/p&gt;
&lt;p&gt;The following is a diagram of the documents and actors which build up the actor
tree, excluding the &lt;code&gt;WindowGlobal&lt;/code&gt; actors. &lt;code&gt;RF{P,C}&lt;/code&gt; stands for
&lt;code&gt;RemoteFrame{Parent,Child}&lt;/code&gt;, and &lt;code&gt;T{P,C}&lt;/code&gt; stands for &lt;code&gt;Tab{Parent,Child}&lt;/code&gt;.
The &lt;code&gt;RemoteFrame&lt;/code&gt; actors are managed by their embedding &lt;code&gt;Tab&lt;/code&gt; actors, and use
the same underlying transport.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- within a.com&amp;#39;s process -

         +-------+
         | TC: 1 |
         +-------+
             |
         +-- 1 --+
         | a.com |
         +-------+
          /     \
    +-- 2 --+ +-------+
    | a.com | | RFC:2 |
    +-------+ +-------+
        |
    +-------+
    | RFC:1 |
    +-------+

- within b.com&amp;#39;s process -

    +-------+    +-------+
    | TC: 2 |    | TC: 3 |
    +-------+    +-------+
        |            |
    +-- 3 --+    +-- 4 --+
    | b.com |    | b.com |
    +-------+    +-------+
                     |
                 +-- 5 --+
                 | b.com |
                 +-------+

- within the parent process -

         +-------+
         | TP: 1 |
         +-------+
          /     \    (manages)
    +-------+ +-------+
    | RFP:1 | | RFP:2 |
    +-------+ +-------+
        |         |
    +-------+ +-------+
    | TP: 2 | | TP: 3 |
    +-------+ +-------+
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;This Newsletter&lt;/h3&gt;
&lt;p&gt;I hope to begin keeping everyone updated on the latest developments with
Fission over the coming months, but am not quite ready to commit to a weekly or
bi-weekly newsletter schedule.&lt;/p&gt;
&lt;p&gt;If you're interested in helping out with the newsletter, please reach out and
let me (Nika) know!.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;Thanks for reading, and best of luck splitting the atom!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.mozilla.org/Project_Fission#Team"&gt;The Project Fission Team&lt;/a&gt;&lt;/p&gt;</content><category term="mozilla"></category><category term="firefox"></category><category term="gecko"></category><category term="fission"></category></entry><entry><title>Partially Generated Classes in C++</title><link href="https://mystor.github.io/partial-cxx-codegen.html" rel="alternate"></link><published>2018-11-24T12:00:00-05:00</published><updated>2018-11-24T12:00:00-05:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2018-11-24:/partial-cxx-codegen.html</id><summary type="html">&lt;p&gt;An interesting problem which I've seen come up decently often in C++ code generators is how to deal with what I'm calling "partially generated classes". We want to generate methods and members for a class which call other methods on that class added by the implementation.&lt;/p&gt;
&lt;h2&gt;Potential Solutions&lt;/h2&gt;
&lt;p&gt;I'm not …&lt;/p&gt;</summary><content type="html">&lt;p&gt;An interesting problem which I've seen come up decently often in C++ code generators is how to deal with what I'm calling "partially generated classes". We want to generate methods and members for a class which call other methods on that class added by the implementation.&lt;/p&gt;
&lt;h2&gt;Potential Solutions&lt;/h2&gt;
&lt;p&gt;I'm not sure what the "best" solution is in this case, but I figured I'd enumerate some of the options avaliable to us with an example. We'll look at how each of these dynamically route a call to a series of impl-defined calls.&lt;/p&gt;
&lt;h3&gt;Virtual Methods&lt;/h3&gt;
&lt;p&gt;The most obvious way I've seen to implement something like this is using C++ inheritance and virtual methods, so let's start with that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen doesn't need to know Impl's concrete name or header&lt;/li&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen must write concrete types for each overrideable method&lt;ul&gt;
&lt;li&gt;This means that the overrides are less flexible&lt;/li&gt;
&lt;li&gt;Could lead to codegen-ing ugly &lt;code&gt;const int&amp;amp;&lt;/code&gt; signatures or similar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unavoidable virtual function call overhead &amp;amp; vtable&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Curious Recurring Template Pattern&lt;/h3&gt;
&lt;p&gt;The most common solution to the virtual method approach I've seen is to use the Curious Recurring Template Pattern. This allows avoidng many of the virtual dispatch downsides, at the cost of requiring generated code end up in a header.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// NOTE: Must be inline!&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen doesn't need to know Impl's concrete name or header&lt;/li&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Every method of Generated needs to be declared in the header&lt;/li&gt;
&lt;li&gt;Unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Knowitall Base Class&lt;/h3&gt;
&lt;p&gt;I don't know of a good name for this potential solution. It's a lot like the CRTP approach, except that it takes advantage of the Codegen's ability to include the Impl's definition in its cpp file to avoid the template parameter.&lt;/p&gt;
&lt;p&gt;I call it a Knowitall Class because it claims to know exactly who is subclassing it, and just downcasts the class hierarchy away.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Codegen.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// Codegen.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;Impl.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Generated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Downcast&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Generated&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen can easily add codegen-private state&lt;/li&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;It's easy to mess up by inheriting a different class from Generated.&lt;ul&gt;
&lt;li&gt;I don't know how big of an issue that this is in most codebases. It could be said that CRTP also has this problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Member Declaration Macros&lt;/h3&gt;
&lt;p&gt;This approach uses a macro to inject the needed method declarations directly into the impl class, which avoids the need for the Generated base class which should only have one subclass.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="cp"&gt;#define DECL_GENERATED_FOR_IMPL() \&lt;/span&gt;
&lt;span class="cp"&gt;    public:                       \&lt;/span&gt;
&lt;span class="cp"&gt;        int RouteCall(int to);    \&lt;/span&gt;
&lt;span class="cp"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* ... */&lt;/span&gt;&lt;span class="cp"&gt;                     \&lt;/span&gt;
&lt;span class="cp"&gt;    public:&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;Impl.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;DECL_GENERATED_FOR_IMPL&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;Cannot easily add codegen-private state&lt;/li&gt;
&lt;li&gt;Uses preprocessor macros, which are a bit ugly to read, write &amp;amp; codegen&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Freestanding Functions&lt;/h3&gt;
&lt;p&gt;Finally, we can take the function-call approach and not declare any methods on Impl at all, instead declaring freestanding methods and using function overloading.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Generated.h&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Generated.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;RouteCall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Impl&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Impl.h&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Impl&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case0&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Case1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* ... */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;The good&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No virtual call overhead &amp;amp; no vtable&lt;/li&gt;
&lt;li&gt;Generated method calls can adapt to Impl's implementation with templates&lt;/li&gt;
&lt;li&gt;Codegen methods may be defined out-of-line&lt;/li&gt;
&lt;li&gt;No unsafe type casting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;The bad&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Codegen needs to know Impl's concrete typename and header&lt;/li&gt;
&lt;li&gt;Cannot easily add codegen-private member variables / state&lt;/li&gt;
&lt;li&gt;Calls to generated methods don't use standard C++ method call syntax.&lt;/li&gt;
&lt;/ul&gt;</content><category term="mozilla"></category><category term="c++"></category><category term="classes"></category><category term="codegen"></category><category term="oop"></category></entry><entry><title>Cleaning up XPConnect</title><link href="https://mystor.github.io/xpconnect-changelog.html" rel="alternate"></link><published>2018-04-30T08:00:00-04:00</published><updated>2018-04-30T08:00:00-04:00</updated><author><name>Nika Layzell</name></author><id>tag:mystor.github.io,2018-04-30:/xpconnect-changelog.html</id><summary type="html">&lt;p&gt;Recently I was working on &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1457972"&gt;some patches&lt;/a&gt; to clean up and improve the code in
Gecko's XPConnect module. As they ended up being somewhat complex &amp;amp; required me
obtaining a lot of information about how XPConnect works, I ended up writing
some pretty in-depth commit messages.&lt;/p&gt;
&lt;p&gt;I figured that they were …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently I was working on &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1457972"&gt;some patches&lt;/a&gt; to clean up and improve the code in
Gecko's XPConnect module. As they ended up being somewhat complex &amp;amp; required me
obtaining a lot of information about how XPConnect works, I ended up writing
some pretty in-depth commit messages.&lt;/p&gt;
&lt;p&gt;I figured that they were pretty much mini blog posts, so I've put them here.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 1: Unify xpconnect cleanup codepaths, r=mccr8&lt;/h3&gt;
&lt;p&gt;It used to be that in XPConnect there were many different pieces of code for
each place where we may need to clean up some untyped values based on their
&lt;code&gt;nsXPTType&lt;/code&gt; information. This was a mess, and meant that every time you needed
to add a new data type you'd have to find every one of these places and add
support for your new type to them.&lt;/p&gt;
&lt;p&gt;In fact, this was bad enough that it appears that I missed some places when
adding my webidl support! Which means that in some edge cases we may clean up
one of these values incorrectly D:!&lt;/p&gt;
&lt;p&gt;This patch adds a new unified method which performs the cleanup by looking at a
&lt;code&gt;nsXPTType&lt;/code&gt; object. The idea is that this function takes a &lt;code&gt;void*&lt;/code&gt; which is
actually a &lt;code&gt;T*&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a value of the &lt;code&gt;nsXPTType&lt;/code&gt; parmaeter. It clears the
value behind the pointer to a valid state such that free-ing the memory would
not cause any leaks. e.g. it free(...)s owned pointers and sets the pointer to
&lt;code&gt;nullptr&lt;/code&gt;, and truncates &lt;code&gt;nsA[C]String&lt;/code&gt; values such that they reference the
static empty string.&lt;/p&gt;
&lt;p&gt;I also modify every one of these custom cleanup codepaths to instead call into
this unified cleanup method.&lt;/p&gt;
&lt;p&gt;This also involved some simplification of helper methods in order to make the
implementation cleaner.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 2: Remove unused code paths in xpconnect, r=mccr8&lt;/h3&gt;
&lt;p&gt;Thanks to the changes in the previous patch, we had some unused code which we
can get rid of. This patch just cleans stuff up a bit.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 3: Remove unnecessary #includes of xptinfo headers, r=mccr8&lt;/h3&gt;
&lt;p&gt;We are going to want to include some "gecko internal" types in more places in
the codebase, and we have unused includes of some of these headers in non-libxul
files.&lt;/p&gt;
&lt;p&gt;This patch just cleans up these unnecssary includes.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 4: Remove dipper types, r=mccr8&lt;/h3&gt;
&lt;p&gt;XPT accrued some weird types and flags over the years, and one of the worst of
these is the "dipper" type flag. This flag was added for &lt;code&gt;ns[C]String&lt;/code&gt; values,
as they needed to be passed indirectly as in and out.&lt;/p&gt;
&lt;p&gt;There was another tool which was added for the same purpose, which was the
"Indirect" behaviour. This flag is set for outparameters by default, and
designates that a value will be passed indirectly, but is also used by jsvals
unconditionally, as jsvals are always passed behind a pointer.&lt;/p&gt;
&lt;p&gt;The effective way that indirect parameters works is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When calling from C++ into JS code, the parameter data pointer is
   dereferenced an extra time before being passed to conversion methods.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When calling from JS into C++ code, a flag is set on the nsXPTCVariant
   object. This flag is read by the platform-specific call code to cause them to
   pass the pointer value stored in &lt;code&gt;nsXPTCVariant::ptr&lt;/code&gt; as the parameter (which
   points to the &lt;code&gt;nsXPTMiniVariant&lt;/code&gt; member) rather than the value stored in the
   variant, thus causing the value to be passed indirectly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For reference dipper parmaeters worked in a different manner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;When calling from C++ into JS code, an extra level of indirection is added to
   the passed-in pointer before passing it to conversion methods, causing the
   pointer passed in to have a "real" type of &lt;code&gt;nsA[C]String**&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When calling from JS into C++ code, a &lt;code&gt;nsA[C]String&lt;/code&gt; object is allocated
   using a custom allocator (which tries to avoid allocating for the first 2
   strings of each type, and after that heap allocates), and the allocation's
   pointer is stored in the variant. The value is not considered as being passed
   "indirectly" for both in and out parameters.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you can see, these two mechanisms take similar but slightly different
approaches. The most notable difference is that in the Indirect case, the "real"
value is assumed to be stored directly in the &lt;code&gt;nsXPTCVariant&lt;/code&gt; object in the JS
-&amp;gt; C++ case. This was probably not done in the past for &lt;code&gt;ns[C]String&lt;/code&gt; as the
&lt;code&gt;nsXPTCVariant&lt;/code&gt; object did not have enough space to allocate a &lt;code&gt;ns[C]String&lt;/code&gt;
object, as it could only hold 8 bytes of information.&lt;/p&gt;
&lt;p&gt;Fortunately for us, we actually have &lt;em&gt;two&lt;/em&gt; variants of &lt;code&gt;nsXPTCVariant&lt;/code&gt;, the
&lt;code&gt;nsXPTCMiniVariant&lt;/code&gt; is what is used most of the time, such as when calling from
C++ into JS, while the &lt;code&gt;nsXPTCVariant&lt;/code&gt; is what is used when we need to actually
allocate space to store whatever value we're passing ourselves (namely it is
only used in the JS -&amp;gt; C++ case).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nsXPTCVariant&lt;/code&gt; is (almost) always allocated on the stack (It is allocated in a
stack-allocated &lt;code&gt;AutoTArray&lt;/code&gt; with a inline capacity of 8. For reference, the
largest parameter count of a JS-exposed xpt method right now is 14 - I
considered bumping the inline capacity up to 16 to make it so we never need to
heap allocate parmaeters, but it seemed like it should be done in a seperate
bug).&lt;/p&gt;
&lt;p&gt;This object is also already pretty big. It has in it:
 1. a &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt; (8 bytes)
 2. a &lt;code&gt;nsXPTType&lt;/code&gt; (3 bytes)
 3. a &lt;code&gt;void*&lt;/code&gt; for indirect calls (8/4 bytes)
 4. a flag byte (1 byte)&lt;/p&gt;
&lt;p&gt;We only need to add enough space to store a &lt;code&gt;ns[C]String&lt;/code&gt; in the
&lt;code&gt;nsXPTCVariant&lt;/code&gt;, and not in &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt;. My approach to this problem was
to make &lt;code&gt;nsXPTCVariant&lt;/code&gt; actually hold a union of a &lt;code&gt;nsXPTCMiniVariant&lt;/code&gt;, and some
storage space for the other, potentially larger information, which we never need
to store in a MiniVariant.&lt;/p&gt;
&lt;p&gt;This allows us to stack allocate the &lt;code&gt;ns[C]Strings&lt;/code&gt; created by XPConnect and
avoid the use of dipper types entirely, in favour of just using indirect values.
It also allows us to delete some of the now-unnecessary custom allocator code
for &lt;code&gt;ns[C]String&lt;/code&gt; objects.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 5: Use modern JS APIs to root jsval temporaries in XPConnect, r=mccr8&lt;/h3&gt;
&lt;p&gt;When a jsval passed from JS code it needs to be stored in a &lt;code&gt;nsXPTCVariant&lt;/code&gt;
object. This object is not rooted by default, as it is stored in some
C++-allocated memory. Currently, we root the values by adding a custom root
using the &lt;code&gt;js::AddRawValueRoot&lt;/code&gt; API, which is deprecated, and only used by this
code and ErrorResult.&lt;/p&gt;
&lt;p&gt;This also has the unfortunate effect that we cannot support XPCOM arrays of
jsvals, as we cannot root all of the values in the array using this API.&lt;/p&gt;
&lt;p&gt;Fortunately, the JS engine has a better rooting API which we can use here
instead. I make the call context a custom rooter, like the &lt;code&gt;SequenceRooter&lt;/code&gt; type
from WebIDL, and make sure to note every jsval when tracing, both in arrays and
as direct values.&lt;/p&gt;
&lt;p&gt;This should allow us to avoid some hashtable operations with roots when
performing XPConnect calls, and remove a consumer of this gross legacy API.&lt;/p&gt;
&lt;p&gt;In addition it allows us to support arrays. This will be even more useful in the
future when I add support for &lt;code&gt;sequence&amp;lt;T&amp;gt;&lt;/code&gt; (which is a &lt;code&gt;nsTArray&amp;lt;T&amp;gt;&lt;/code&gt;) to xpidl
and xpconnect.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 6: Ensure the extended types list has some basic types with known indexes, r=mccr8&lt;/h3&gt;
&lt;p&gt;Currently &lt;code&gt;XPCVariant&lt;/code&gt; has some code for working with arrays of a series of
basic types. I want to unify and simplify code which works with &lt;code&gt;nsXPTTypes&lt;/code&gt; to
always take the topmost level type (rather than passing in an array element type
when working with an array).&lt;/p&gt;
&lt;p&gt;This is pretty easy for most of XPConnect, but &lt;code&gt;XPCVariant&lt;/code&gt; occasionally needs
to perform calls on made-up array types, which isn't compatible with the current
implementation. Fortunately, it only needs a very small set of array types. This
patch adds a set of simple types (mostly the arithmetic types and
&lt;code&gt;TD_INTERFACE_IS_TYPE&lt;/code&gt; for interfaces) to the extra types array unconditionally
with a known index, for &lt;code&gt;XPCVariant&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An other option I was considering was to consider the value &lt;code&gt;0xff&lt;/code&gt; in the data
byte on &lt;code&gt;nsXPTType&lt;/code&gt; to be a flag which indicates that the array element type is
actually the type immediately following the current &lt;code&gt;nsXPTType&lt;/code&gt; object in
memory, but that was incompatible with many of the existing &lt;code&gt;nsXPTType&lt;/code&gt;
consumers which copy the &lt;code&gt;nsXPTType&lt;/code&gt; objects around (e.g. onto the stack),
rather than always using them by reference, so I decided it was not a good
approach to take.&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 7: Eliminate XPCConvert::NativeStringWithSize2JS/JSStringWithSize2Native, r=mccr8&lt;/h3&gt;
&lt;p&gt;XPIDL supports explicitly sized string types. These types currently have to be
handled by a separate entry point into &lt;code&gt;XPCConvert&lt;/code&gt;, and don't share any logic
with the implicitly sized string types.&lt;/p&gt;
&lt;p&gt;If we just add an array length parameter to the basic &lt;code&gt;JSData2Native&lt;/code&gt; and
&lt;code&gt;NativeData2JS&lt;/code&gt; methods we can handle them in the same place as every other
type.&lt;/p&gt;
&lt;p&gt;This also allows us to share a lot of code with non-sized string types, which is
nice :-).&lt;/p&gt;
&lt;h3&gt;Bug 1457972 - Part 8: Remove external consumers of XPCConvert::NativeArray2JS/JSArray2Native, r=mccr8&lt;/h3&gt;
&lt;p&gt;Current XPIDL native arrays currently also require a custom entry point. With
the new arraylen parameter we can handle them in
&lt;code&gt;JSData2Native&lt;/code&gt;/&lt;code&gt;NativeData2JS&lt;/code&gt;. As these methods are more complex and don't
share logic with an existing codepath, I keep them in external helper methods.&lt;/p&gt;</content><category term="mozilla"></category><category term="c++"></category><category term="programming"></category><category term="gecko"></category><category term="xpconnect"></category></entry></feed>